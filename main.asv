%% Initialization
clear; clc; close all;

% Clustering algorithm
if ~exist('spectral_clustering.m', 'file')
    error('Please ensure spectral_clustering.m inside the current file');
end

%% ==========================================================
% Analyse Example 1 (Real data - Medical Innovation)
% ==========================================================
disp('Analysing Example 1...');
file1 = "example1.dat";

% Determine the optimal number of clusters k (Eigengap Heuristic)
% Request a larger k(15) first, to observe the distribution of eigenvalues
k_inspect = 15;
[~, evals1, ~, ~] = spectral_clustering(file1, k_inspect);

% 绘制特征值分布图
figure('Name', 'Example 1 Analysis');
subplot(2, 2, 1);
plot(evals1, 'o-', 'LineWidth', 1.5, 'MarkerFaceColor', 'b');
title('Ex1: Eigenvalues');
xlabel('Index k'); ylabel('Eigenvalue \lambda');
grid on;

% 特征值较小且稳定的部分对应簇的数量，随后特征值会发生跳跃。
% 对于该数据集（4个城镇的医生），通常在 k=4 处会有 Gap。
k1_optimal = 4; 
xline(k1_optimal, '--r', ['Chosen k=' num2str(k1_optimal)]);
text(k1_optimal, evals1(k1_optimal), '  \leftarrow Gap here', 'Color', 'r');

% 使用最佳 k 进行最终聚类
[labels1, ~, eigvecs1, ~] = spectral_clustering(file1, k1_optimal);

% 可视化结果 (排序后的邻接矩阵 Spy Plot)
raw1 = readmatrix(file1);
i1 = raw1(:,1); j1 = raw1(:,2);
if min([i1;j1])==0, i1=i1+1; j1=j1+1; end % 0-based 转 1-based
n1 = max([i1;j1]);
A1 = sparse(i1, j1, 1, n1, n1); A1 = A1 + A1.'; % 对称化

% 根据聚类结果对节点进行排序
[~, sort_idx1] = sort(labels1);
sorted_A1 = A1(sort_idx1, sort_idx1);

subplot(2, 2, 2);
spy(sorted_A1);
title(['Ex1: Adjacency Matrix (Sorted by k=' num2str(k1_optimal) ')']);
xlabel('Nodes (sorted)');

% 二维嵌入可视化 (如果 k>=3)
% NJW 算法使用特征向量作为坐标
subplot(2, 2, [3 4]);
% 使用第2和第3个特征向量画图 (第1个在 Normalized Laplacian 中通常包含较少信息或为平滑分量)
scatter(eigvecs1(:,2), eigvecs1(:,3), 30, labels1, 'filled');
title('Ex1: 2D Embedding (Eigenvectors 2 vs 3)');
grid on; colorbar;

%% ==========================================================
%  Analyse Example 2 (合成数据)
% ==========================================================
disp('Analysing Example 2...');
file2 = "example2.dat";

% 确定最佳聚类数 k
k_inspect = 10;
[~, evals2, ~, ~] = spectral_clustering(file2, k_inspect);

figure('Name', 'Example 2 Analysis');
subplot(2, 2, 1);
plot(evals2, 's-', 'LineWidth', 1.5, 'MarkerFaceColor', 'g');
title('Ex2: Eigenvalues');
xlabel('Index k'); ylabel('Eigenvalue \lambda');
grid on;

% 观察 plot，寻找断崖式上升点。
% 假设 example2 是两个明显的社区 (根据通常的 dataset 命名习惯)，选 k=2。
% 根据运行出来的图调整这个值。
k2_optimal = 2; 
xline(k2_optimal, '--r', ['Chosen k=' num2str(k2_optimal)]);

% 运行聚类
[labels2, ~, eigvecs2, ~] = spectral_clustering(file2, k2_optimal);

% 可视化排序矩阵
raw2 = readmatrix(file2);
i2 = raw2(:,1); j2 = raw2(:,2);
if min([i2;j2])==0, i2=i2+1; j2=j2+1; end
n2 = max([i2;j2]);
% Example2 可能有权重列，如果有第3列作为权重：
if size(raw2, 2) >= 3
    w2 = raw2(:,3);
    A2 = sparse(i2, j2, w2, n2, n2);
else
    A2 = sparse(i2, j2, 1, n2, n2);
end
A2 = A2 + A2.';

[~, sort_idx2] = sort(labels2);
sorted_A2 = A2(sort_idx2, sort_idx2);

subplot(2, 2, 2);
spy(sorted_A2);
title(['Ex2: Adjacency Matrix (Sorted by k=' num2str(k2_optimal) ')']);

% 二维嵌入可视化
subplot(2, 2, [3 4]);
scatter(eigvecs2(:,1), eigvecs2(:,2), 30, labels2, 'filled');
title('Ex2: 2D Embedding (Eigenvectors 1 vs 2)');
grid on; axis equal;
